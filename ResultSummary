Much like our Exhaustive Knapsack, we needed to test all possible combinations to find the best-case for each graph. What becomes more complex is the different states every item can hold, every node in the graph coloring scheme can have a different state for every possible color available. Much like a combination lock we end up with a number of combinations equal to: (Number of Colors) ^ (Number of Nodes). To test this, we looked to creating a base number converter. For example, if we wanted to progress through three colors for three nodes we get this:
(3 colors) ^ (3 Nodes) = 27 Combinations
000 001 002 010 011 012 020 021 022 100 101 102 110 â€¦ 222
Where each color is represented with a number.
This array of states or colors can be mapped easily to the nodes and tested for conflicts. The algorithm stops if a solution with no conflicts is reached, each combination has been attempted, or the time limit is reached. With the given instances, we were able to observe each of these cases at work. Color12-3 was small enough that our algorithm went through all combinations before exiting, managing to reduce the number of conflicts to 1. When running the algorithm on the instance color 12-4, it managed to find a combinations of colors which resulted in zero conflicts. This program behaves as a bad hueristic for large instances because of the amount of time it takes. It'll always be biased towrds testing the front nodes.
